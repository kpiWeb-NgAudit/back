package kpiweb.app.dev.entity;

import jakarta.persistence.*; // Or javax.persistence.* for older Spring Boot / Java EE
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime; // Modern way to handle datetime
// import java.util.Date; // Alternative for datetime if not using Java 8+ time API
import java.sql.Timestamp; // SQL Server timestamp (rowversion) is best mapped to byte[] or long

@Entity
@Table(name = "facts", schema = "dbo")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Fact {

    @Id
    @Column(name = "fact_id_pk", nullable = false)
    // If this ID is auto-generated by the database (e.g., IDENTITY):
    // @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer factIdPk;

    @Column(name = "fact_tname", nullable = false, length = 40)
    private String factTname;

    @Column(name = "fact_type", nullable = false, length = 16)
    private String factType;

    @Column(name = "factdbextr_id_pk") // nullable = true is default
    private Integer factdbextrIdPk;

    @Column(name = "fact_proccube", nullable = false, length = 12)
    private String factProccube;

    @Column(name = "fact_shortcubename", nullable = false, length = 40)
    private String factShortcubename;

    @Column(name = "fact_shortpresname", nullable = false, length = 60)
    private String factShortpresname;

    @Column(name = "fact_workorder", nullable = false)
    private Integer factWorkorder;

    @Column(name = "cube_id_pk", nullable = false, length = 30) // Matches the DB column
    private String cubeIdPk;

    @Column(name = "fact_factdatafiletype", length = 20)
    private String factFactdatafiletype;

    @Column(name = "fact_factdatafilename", length = 100)
    private String factFactdatafilename;

    @Column(name = "fact_factdatafilecheckunicity")
    private Boolean factFactdatafilecheckunicity; // bit maps to Boolean

    @Column(name = "fact_zonespe", nullable = false, length = 12)
    private String factZonespe;

    @Column(name = "fact_lastupdate", nullable = false)
    private LocalDateTime factLastupdate; // Or java.util.Date or java.sql.Timestamp

    @Lob // For TEXT type, indicates a Large Object
    @Column(name = "fact_comments", columnDefinition = "TEXT")
    private String factComments;

    @Column(name = "fact_partitiontype", nullable = false, length = 14)
    private String factPartitiontype;

    @Version // JPA annotation for optimistic locking using a version column
    @Column(name = "fact_timestamp", nullable = false, columnDefinition = "TIMESTAMP")
    private byte[] factTimestamp; // SQL Server 'timestamp' is a rowversion, best mapped to byte[]


    @ManyToOne(fetch = FetchType.LAZY) // LAZY is generally good for performance
    @JoinColumn(name = "cube_id_pk", referencedColumnName = "cube_id_pk", insertable = false, updatable = false)
    // name = "cube_id_pk" is the FK column in the 'facts_table'
    // referencedColumnName = "cube_id_pk" is the PK column in the 'customers' table
    // insertable = false, updatable = false because the ID is managed by cubeIdPkValue
    private Customer customer;


    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
        if (customer != null) {
            this.cubeIdPk = customer.getCubeIdPk(); // Keep them in sync
        } else {
            this.cubeIdPk = null;
        }
    }




    // --- Optional: toString(), equals(), hashCode() ---
    // (Good practice to override these, especially if using entities in collections)

    @Override
    public String toString() {
        return "Fact{" +
                "factIdPk=" + factIdPk +
                ", factTname='" + factTname + '\'' +
                // ... add other fields
                '}';
    }

    // equals() and hashCode() should ideally be based on the primary key
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Fact fact = (Fact) o;
        return factIdPk != null && factIdPk.equals(fact.factIdPk);
    }

    @Override
    public int hashCode() {
        return factIdPk != null ? factIdPk.hashCode() : 0;
    }
}
